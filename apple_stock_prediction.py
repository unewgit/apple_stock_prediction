# -*- coding: utf-8 -*-
"""apple stock prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19ibk5r4VA5BGZB7ePQJBS6e_WVtZ4Vp9
"""

import pandas as pd
import numpy as np
from plotly.subplots import make_subplots
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout

# For graphs
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objs as go

import os

df = pd.read_csv("AAPL.csv")
df

df.info()

df.describe().T.apply(lambda x: x.apply("{0:.3f}".format))

df["Date"] = pd.to_datetime(df["Date"])

df = df.set_index("Date")
fig = make_subplots(rows=6, cols=1,
                    subplot_titles=("Opening Price", "Closing Price", "Highest Price",
                                    "Lowest Price", "Adjusted Closing Price", "Volume"))

fig.add_trace(go.Scatter(x=df.index, y=df["Open"]), row=1, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df["Close"]), row=2, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df["High"]), row=3, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df["Low"]), row=4, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df["Adj Close"]), row=5, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df["Volume"]), row=6, col=1)
fig.update_layout(showlegend=False, height=1200, width=800)
fig.show()

df_last_10_years = df['2014-01-01':'2023-12-31']

fig = go.Figure(data=go.Ohlc(x=df_last_10_years.index,
                             open=df_last_10_years["Open"],
                             high=df_last_10_years["High"],
                             low=df_last_10_years["Low"],
                             close=df_last_10_years["Close"]))

fig.update_layout(
    title="OHLC Chart for Apple (2014-2023)",
    title_x=0.5,
    xaxis_rangeslider_visible=False
)

fig.show()

df_last_10_years = df['2015-01-01':'2023-12-31']

# Calculate Simple Moving Average
simple_ma = df_last_10_years["Close"].rolling(window=100).mean()

# Plotting
plt.figure(figsize=(14,8))
simple_ma.plot(label="Simple Moving Average")
df_last_10_years["Close"].plot(label="Closing Price")
plt.xticks(rotation=0)
plt.title("Moving Average of Closing Price for Apple (2014-2023)", size=15)
plt.legend()
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

df_last_10_years = df['2014-01-01':'2023-12-31']

results = seasonal_decompose(df_last_10_years["Close"], model="multiplicative", period=252)

fig = results.plot()
fig.set_size_inches(12, 8)
fig.tight_layout()
plt.show()

trainData = df.iloc[:, 1:2].values
trainData.shape

scaler = MinMaxScaler()
trainData = scaler.fit_transform(trainData)
trainData

X_train = []
y_train = []

for i in range(60, 10409):
    X_train.append(trainData[i-60:i, 0])
    y_train.append(trainData[i, 0])


X_train, y_train = np.array(X_train), np.array(y_train)

print(X_train.shape)
print(y_train.shape)

X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
X_train.shape

model = Sequential()

model.add(LSTM(units = 100, return_sequences = True, input_shape = (X_train.shape[1], 1)))
model.add(Dropout(0.2))

model.add(LSTM(units = 100, return_sequences = True))
model.add(Dropout(0.2))

model.add(LSTM(units = 100, return_sequences = True))
model.add(Dropout(0.2))

model.add(LSTM(units = 100, return_sequences = False))
model.add(Dropout(0.2))

model.add(Dense(units = 1))
model.compile(optimizer = 'adam', loss = 'mean_squared_error')

hist = model.fit(X_train, y_train, epochs = 7, batch_size = 64, verbose = 2)

plt.plot(hist.history['loss'])
plt.title('Loss from the Training Model')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train'], loc = 'upper left')
plt.show()

testData = pd.read_csv("AAPL.csv")
testData['Open'] = pd.to_numeric(testData.Open, errors = 'coerce')
testData = testData.dropna()
testData = testData.iloc[:, 1:2]
y_test = testData.iloc[60:, 0:].values

inputOpen = testData.iloc[:, 0:].values
inputOpen_scaled = scaler.transform(inputOpen)
inputOpen_scaled.shape

X_test = []
length = len(testData)
timestep = 60
for i in range(timestep, length):
    X_test.append(inputOpen_scaled[i-timestep:i, 0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
X_test.shape

y_pred = model.predict(X_test)

predicted_price = scaler.inverse_transform(y_pred)

plt.plot(y_test, color = 'red', label = 'Actual Stock Price')
plt.plot(predicted_price, color = 'green', label = 'predicted Stock Price')
plt.title('APPLE stock price prediction')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()

from sklearn.metrics import mean_squared_error
import math

# Calculate RMSE
rmse = math.sqrt(mean_squared_error(y_test, predicted_price))
print(f'Root Mean Squared Error (RMSE): {rmse}')